<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="[TOC]  大纲Glide 是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。文章主要针对version: 4.2.0的源码进行分析, 文章分为几部分:  总体设计简介主要介绍一张图片在第一/二次加载时所经过的完整流程, 脱离源码, 抽象的了解Glide的主要思想 主要模">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide源码分析(version: 4.2.0)">
<meta property="og:url" content="http://yoursite.com/2018/04/17/Glide源码分析-version-4-2-0/index.html">
<meta property="og:site_name" content="Cat&#39;s 小窝">
<meta property="og:description" content="[TOC]  大纲Glide 是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。文章主要针对version: 4.2.0的源码进行分析, 文章分为几部分:  总体设计简介主要介绍一张图片在第一/二次加载时所经过的完整流程, 脱离源码, 抽象的了解Glide的主要思想 主要模">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUv2K.jpg">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUPVG.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUCFQ.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUewz.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUhE3.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BU4q6.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUuAB.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BULAa.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUEs2.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUZjp.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUclE.png">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUavn.jpg">
<meta property="og:image" content="https://s1.ax2x.com/2017/11/02/BUssJ.png">
<meta property="og:updated_time" content="2018-04-17T07:52:04.393Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide源码分析(version: 4.2.0)">
<meta name="twitter:description" content="[TOC]  大纲Glide 是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。文章主要针对version: 4.2.0的源码进行分析, 文章分为几部分:  总体设计简介主要介绍一张图片在第一/二次加载时所经过的完整流程, 脱离源码, 抽象的了解Glide的主要思想 主要模">
<meta name="twitter:image" content="https://s1.ax2x.com/2017/11/02/BUv2K.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/17/Glide源码分析-version-4-2-0/"/>





  <title>Glide源码分析(version: 4.2.0) | Cat's 小窝</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cat's 小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/Glide源码分析-version-4-2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="G33kC4t">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cat's 小窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Glide源码分析(version: 4.2.0)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T15:50:58+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<hr>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><a href="http://bumptech.github.io/glide/" target="_blank" rel="noopener">Glide</a> 是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。<br>文章主要针对version: 4.2.0的源码进行分析, 文章分为几部分:</p>
<ul>
<li>总体设计简介<br>主要介绍一张图片在第一/二次加载时所经过的完整流程, 脱离源码, 抽象的了解Glide的主要思想</li>
<li>主要模块和功能说明<br>这部分将全面了解Glide中所包含的各个模块, 以及他们的作用, 并且通过uml图, 对各个模块的依赖关系进行分析</li>
<li>详细流程解析<br>这部分在源码的角度, 对请求的各种状态转换进行分析, 目地是完全掌握Glide的加载流程, 对Glide的设计思想有全面的了解, 这部分还会对部分模块进行解析, 比如解码模块对BitmapPool的使用, 这个模块会随着研究的深入不断扩展, 将Glide设计的比较好的模块都展现出来</li>
<li>使用方法进阶<br>这部分将补充一些官网没有的例子</li>
</ul>
<h1 id="总体设计简介"><a href="#总体设计简介" class="headerlink" title="总体设计简介"></a>总体设计简介</h1><p>Glide总体设计层次:<br><img src="https://s1.ax2x.com/2017/11/02/BUv2K.jpg" alt=""> </p>
<p>Glide 主要类关系图:<br><img src="https://s1.ax2x.com/2017/11/02/BUPVG.png" alt=""></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在了解Glide源码之前, 我们首先要了解一些概念, 也是Glide文档中经常引用的一些名词:</p>
<ul>
<li>data ：代表原始的，未修改过的资源，对应dataClass</li>
<li>resource : 修改过的资源，对应resourceClass, 由data生成</li>
<li>transcode : 转换后的资源, 对应transcodeClass, 由resource生成</li>
<li>Transformation : 比如对图片进行FitCenter，CircleCrop，CenterCrop的transformation，或者根据给定宽高对Bitmap进行处理的BitmapDrawableTransformation</li>
</ul>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>我们从一个基本的加载请求开始解析, 用注释来说明请求设置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(activity) <span class="comment">// 绑定生命周期</span></span><br><span class="line">    .load(uri) <span class="comment">// 设置数据源</span></span><br><span class="line">    .listener(...) <span class="comment">// 设置监听</span></span><br><span class="line">    .centerCrop()</span><br><span class="line">    .... <span class="comment">// 设置各种配置</span></span><br><span class="line">    .into(imageView) <span class="comment">// 绑定需要显示的view, 并开始请求</span></span><br></pre></td></tr></table></figure></p>
<p>以上示例展示了一个请求的基本流程:<br>获取一个与Acitivity绑定的请求管理器(RequestManager) <strong>-&gt;</strong><br>根据数据源获取的一个请求(Request) <strong>-&gt;</strong><br>设置监听(可选) <strong>-&gt;</strong><br>修改请求可配置参数(RequestOptions) <strong>-&gt;</strong><br>绑定一个显示层并生成target(对显示层的封装), 并且开始请求.<br>接下来我们通过流程图展示一个请求的基本流程:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BUCFQ.png" alt=""></p>
<p>流程中忽略了错误/手动取消等异常情况, 也未关注用户设置的一些选项对流程所造成的影响, 例如不加载本地缓存等.<br>流程图主要体现了Glide加载和处理图片的基本步骤和三级缓存模型. 接下来根据基本请求流程, 我们对流程中所使用的模块做详解.</p>
<h1 id="主要模块-类和功能说明"><a href="#主要模块-类和功能说明" class="headerlink" title="主要模块/类和功能说明"></a>主要模块/类和功能说明</h1><p>这里将描述Glide的主要模块, 包括了整体架构部分和细分功能部分. 例如我们将分析都有哪些管理器控制参与了Glide各种资源和模块的调度, 同时也会列出每一个子功能都是由哪些模块完成的. 我们将整个Glide模块分为三部分说明:</p>
<ul>
<li>请求管理部分, 主要负责请求流程的控制. 我们将通过这个模块了解Glide的内部运行的基本逻辑</li>
<li>数据处理部分, 主要负责数据的加载和保存, 还有编解码等, 我们将通过这个模块了解Glide可提供的各种数据加载方式和如何定义自己的加载显示方式, 同时这个模块的架构也体现了Glide的功能强大</li>
<li>配置部分, 主要负责向用户提供各种可选参数, 我们将通过这个模块了解Glide提供的各种功能</li>
</ul>
<h2 id="请求管理部分"><a href="#请求管理部分" class="headerlink" title="请求管理部分"></a>请求管理部分</h2><p>Glide的单个请求模型基于MVC模式, 同时又通过RequestManager 将多个请求绑定到一个Activity/Fragment上, 来同步生命. 单个请求的MVC主要通过三个模块实现:</p>
<ul>
<li>Traget 是显示层接口(V), 处理好的数据会设置给Target, 我们可以通过自定义Target来觉得数据的显示方式</li>
<li>Request 是控制器(C), 我们可以通过Request来开始或取消一个请求</li>
<li>Engine 是数据提供者(M), Engine是一个全局模块, 在Glide初始化时被设置进来, 单个任务由EngineJob类来具体执行, Engine是所有任务的管理器. Request通过Engine获取数据, 在设置给Traget, 同时更新自身状态.</li>
</ul>
<p>下面我们将对单个模块详细解读.</p>
<h3 id="RequestManager-管理一组请求"><a href="#RequestManager-管理一组请求" class="headerlink" title="RequestManager 管理一组请求"></a>RequestManager 管理一组请求</h3><p>RequestManager模块为请求开始创建的第一个模块, 由with函数创建, 其实例生命周期与activity/fragment的生命周期相同, 换句话说, 每个Activity/Fragment都与一个不同的RequestManager绑定, 管理其内部的一组图片加载请求. RequestManager的主要功能为:</p>
<ul>
<li>监听所属的Activity/Fragment的状态</li>
<li>监听网络状态</li>
<li>保存默认的RequestOptions</li>
<li>维护请求队列</li>
<li>创建RequestBuilder, 作为Request工厂来使用</li>
</ul>
<p>内部字段比较好理解, 就不一一列出</p>
<h3 id="Target-资源接收模块"><a href="#Target-资源接收模块" class="headerlink" title="Target 资源接收模块"></a>Target 资源接收模块</h3><p>Target接口扮演了资源接受者的角色, 其功能有</p>
<ul>
<li>接收由请求模块处理好的资源</li>
<li>计算和提供资源实际大小</li>
<li>控制显示层显示行为</li>
</ul>
<p>通过Target类族中的子类, 我们能了解当前glide都支持哪些组件作为显示层, 来接收资源, 以下是Target的UML继承关系图:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BUewz.png" alt=""></p>
<p>我们可以看到, Glide不仅仅支持ImageView, 还可以给Notification/Widget等设置, 还可以通过FutureTarget直接获得资源.</p>
<h3 id="Request-请求控制"><a href="#Request-请求控制" class="headerlink" title="Request 请求控制"></a>Request 请求控制</h3><p>Request 有两个子类, 为SingleRequest/ThumbnailRequestCoordinator, 分别为加载的具体实现和缩略图加载实现. Request 负责管理一个资源的请求状态, 主要有以下几种功能:</p>
<ul>
<li>维护请求状态, 状态转换图见详细流程-请求流程部分</li>
<li>与请求引擎(Engine)通信, 与Target通信, 调度数据层和显示层</li>
<li>提供取消接口</li>
</ul>
<h3 id="Engine-数据加载模块"><a href="#Engine-数据加载模块" class="headerlink" title="Engine 数据加载模块"></a>Engine 数据加载模块</h3><p>Engine 类是整个数据加载部分的入口, 所有数据加载均从load入口开始, 数据加载模块由下面解析, 这里主要看一下load函数的参数:<br>Engine类说明见文档: <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/430/index.html" target="_blank" rel="noopener">https://muyangmin.github.io/glide-docs-cn/javadocs/430/index.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext, // Glide上下文, 暂时不管</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model, // 数据源, 就是load时候设置的那个</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature, // 请求的特征标识</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass, // 资源类型, 标识数据源是一个什么类型的资源</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass, // 转换资源类型, 标识结果是一个什么类型的资源</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority, // 优先级</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy, // 磁盘缓存</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, // 资源转换器集合</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired, // 是否必须转换, 详细见配置部分 </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform, // 是否使用硬解码</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options, // 操作集合, 用来保存将要对资源进行操作的指令</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable, // 是否保存内存缓存</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool, // 是否使用无限制的线程池</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,// 仅从缓存加载, 没有缓存报错</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb)</span> <span class="comment">// 资源回调</span></span></span><br></pre></td></tr></table></figure>
<h2 id="数据处理部分"><a href="#数据处理部分" class="headerlink" title="数据处理部分"></a>数据处理部分</h2><p>由Engine类管理的数据处理部分, 代理了所有数据的加载/转换和保存, 是Glide三层缓存模型的核心部分. 数据处理主要分为以下模块:</p>
<ul>
<li>任务管理模块, EngineJob/DecodeJob等</li>
<li>ModelLoader, 用于加载自定义的 Model(Url, Uri,任意的 POJO )和 Data(InputStreams, FileDescriptors)。</li>
<li>ResourceDecoder, 用于对新的 Resources(Drawables, Bitmaps)或新的 Data 类型(InputStreams, FileDescriptors)进行解码。</li>
<li>Encoder, 用于向 Glide 的磁盘缓存写 Data (InputStreams, FileDesciptors)。</li>
<li>ResourceTranscoder，用于在不同的资源类型之间做转换，例如，从 BitmapResource 转换为 DrawableResource 。</li>
<li>ResourceEncoder，用于向 Glide 的磁盘缓存写 Resources(BitmapResource, DrawableResource)。</li>
<li>Resource, 表示一个基本资源, 是对Glide所加载的资源的封装, 你也可以用过as自定义一个资源. 前面的加载器每一步最终都会生成一个Resource, 然后再转换成另一个Resource.</li>
<li>DataFetcher, 资源加载器的实现, 是实际的资源加载工具, 由ModelLoader创建. 如果说ModelLoader是数据源类型与加载器的映射, 它则是加载器与实际加载方式的映射.</li>
<li>Cache/Pool, 对加载过程中产生的中间对象的缓存, 包括三种类型的缓存. 对结果的缓存, 包括内存缓存和磁盘缓存, 主要使用LRU算法管理缓存, 这里不单独介绍</li>
</ul>
<p>可见除了任务管理部分外, 其他模块均可以很容易的自定义实现, 也可添加多组, 这也是Glide设计的强大的地方.<br>下面我们对细分模块进行介绍:</p>
<h3 id="EngineJob-DecodeJob"><a href="#EngineJob-DecodeJob" class="headerlink" title="EngineJob/DecodeJob"></a>EngineJob/DecodeJob</h3><p>EngineJob 和 DecodeJob 一一对应, </p>
<ul>
<li>EngineJob 负责调度线程, 切换线程, 任务的重发/取消等逻辑. </li>
<li>DecodeJob 负责处理任务和EngineJob间的通信, DecodeJob 是一个任务的基本执行单元, 维护了任务的状态. 源码会在后面详细解析</li>
</ul>
<h3 id="ModelLoader-数据源加载器"><a href="#ModelLoader-数据源加载器" class="headerlink" title="ModelLoader 数据源加载器"></a>ModelLoader 数据源加载器</h3><p>Glide 所提供的默认数据源加载器由以下UML列出:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BUhE3.png" alt="ModelLoader "></p>
<p>通过查看ModelLoader的设置, 我们可以知道我们都可以设置什么样的数据源来加载图片, 对应类型的设置在Glide类的构造函数中, 我就不一一列举了.<br>例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.append(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpGlideUrlLoader.Factory())</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceDecoder"><a href="#ResourceDecoder" class="headerlink" title="ResourceDecoder"></a>ResourceDecoder</h3><p>ResourceDecoder 资源加载器, 将通过ModelLoder生成的数据源转化为Resource, 例如Bitmap, Drawable等. 以下为ResourceDecoder支持的子类的UML图:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BU4q6.png" alt="ResourceDecoder"></p>
<p>对应Glide中的设置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,<span class="keyword">new</span> ByteBufferBitmapDecoder(downsampler))</span><br></pre></td></tr></table></figure></p>
<h3 id="Encoder-ResourceEncoder"><a href="#Encoder-ResourceEncoder" class="headerlink" title="Encoder/ResourceEncoder"></a>Encoder/ResourceEncoder</h3><p>Encoder 资源保存器, 将加载好的资源保存到缓存文件, 默认设置仅对网路请求保存, 所支持的保存方式对应UML图为:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BUuAB.png" alt="Encoder"></p>
<p>对应Glide中的设置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.append(InputStream.class, <span class="keyword">new</span> StreamEncoder(arrayPool))</span><br><span class="line">.append(Bitmap.class, <span class="keyword">new</span> BitmapEncoder())</span><br></pre></td></tr></table></figure>
<h3 id="ResourceTranscoder"><a href="#ResourceTranscoder" class="headerlink" title="ResourceTranscoder"></a>ResourceTranscoder</h3><p>资源转换器, 对资源进行转换, 例如当前可能有一个ResourceDecoder可以把Data转化为ByteArray, 但是不能转化为as设置的可用的Resource, 此时通过这种方式转换 ,所支持的转换的子类的UML:<br><img src="https://s1.ax2x.com/2017/11/02/BULAa.png" alt=""><br>对应Glide中的设置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.register(Bitmap.class, BitmapDrawable.class, <span class="keyword">new</span> BitmapDrawableTranscoder(resources, bitmapPool))</span><br></pre></td></tr></table></figure>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>资源类型封装, 用来表示资源的POJO, 默认的资源类型的UML:<br><img src="https://s1.ax2x.com/2017/11/02/BUEs2.png" alt="Resource"></p>
<h3 id="DataFetcher"><a href="#DataFetcher" class="headerlink" title="DataFetcher"></a>DataFetcher</h3><p>数据源加载的实际执行者, ModelLoader通过buildLoadData函数将DataFetcher与生成的KEY绑定, 主要方便对加载结果的缓存. DataFetcher的默认功能UML图为:<br><img src="https://s1.ax2x.com/2017/11/02/BUZjp.png" alt="DataFetcher"></p>
<h2 id="配置部分"><a href="#配置部分" class="headerlink" title="配置部分"></a>配置部分</h2><p>Glide有两部分可配参数, 全局配置和Request配置. 分别对应类GlideBuilder和RequestOptions, 接下来将对配置参数一一说明:</p>
<h3 id="GlideBuilder"><a href="#GlideBuilder" class="headerlink" title="GlideBuilder"></a>GlideBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A builder class for setting default structural classes for Glide to use.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions = <span class="keyword">new</span> ArrayMap&lt;&gt;(); <span class="comment">// 默认的资源加载完成后的显示动画, 这里可以设置默认的显示动画, 在4.0以后不再有默认的加载动画, 需要自己设置</span></span><br><span class="line">  <span class="keyword">private</span> Engine engine; <span class="comment">// 数据加载模块 - 不可自己设置</span></span><br><span class="line">  <span class="keyword">private</span> BitmapPool bitmapPool; <span class="comment">// bitmap缓存池</span></span><br><span class="line">  <span class="keyword">private</span> ArrayPool arrayPool; <span class="comment">// 数组资源缓存池</span></span><br><span class="line">  <span class="keyword">private</span> MemoryCache memoryCache; <span class="comment">// 内存缓存管理模块</span></span><br><span class="line">  <span class="keyword">private</span> GlideExecutor sourceExecutor; <span class="comment">// 数据源加载线程池, 当从数据源加载数据时, 使用这个线程池</span></span><br><span class="line">  <span class="keyword">private</span> GlideExecutor diskCacheExecutor; <span class="comment">// 磁盘缓存加载线程池, 当从磁盘缓存(DataCache, ResourceCache)中加载使用这个线程池,</span></span><br><span class="line">  <span class="keyword">private</span> DiskCache.Factory diskCacheFactory; <span class="comment">// 磁盘缓存管理</span></span><br><span class="line">  <span class="keyword">private</span> MemorySizeCalculator memorySizeCalculator; <span class="comment">// 内存缓存大小计算工具, 用来控制BitmapPool, ArrayPool, MemoryCache的大小</span></span><br><span class="line">  <span class="keyword">private</span> ConnectivityMonitorFactory connectivityMonitorFactory; <span class="comment">// 网络状态监听</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> logLevel = Log.INFO; <span class="comment">// 日志</span></span><br><span class="line">  <span class="keyword">private</span> RequestOptions defaultRequestOptions = <span class="keyword">new</span> RequestOptions(); <span class="comment">// 默认的请求参数</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> RequestManagerFactory requestManagerFactory; <span class="comment">// 请求生成的工厂, 使用抽象工厂模式, 通过@GlideExtension注解扩展request, 详见[Generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html)</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestOptions"><a href="#RequestOptions" class="headerlink" title="RequestOptions"></a>RequestOptions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Provides type independent options to customize loads with Glide.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"PMD.UseUtilityClass"</span>, <span class="string">"unused"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestOptions</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 前面一些默认的参数和对clone的处理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> sizeMultiplier = <span class="number">1f</span>; <span class="comment">// 图片缩略尺寸,  可以用来设置缩略图</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC; <span class="comment">// 磁盘缓存策略</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> Priority priority = Priority.NORMAL; <span class="comment">// 请求优先级</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Drawable errorPlaceholder; <span class="comment">// 加载错误时候的图片</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> errorId; <span class="comment">// 加载错误时加载的资源ID</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Drawable placeholderDrawable; <span class="comment">// 默认图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> placeholderId; <span class="comment">// 默认图ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCacheable = <span class="keyword">true</span>; <span class="comment">// 是否缓存 (内存缓存)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> overrideHeight = RequestOptions.UNSET; <span class="comment">// 覆盖高度, 如果设置了这个参数, 会覆盖view的高度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> overrideWidth = RequestOptions.UNSET; <span class="comment">// 同上</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> Key signature = EmptySignature.obtain(); <span class="comment">// 请求的特殊标识, 可以设置这个参数将两个相同的请求区分开, 让他们分别加载</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isTransformationRequired; <span class="comment">// 强制必须有转换参数, 设置了这个参数后, 如果没有设置Transformation, 加载过程会报错</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isTransformationAllowed = <span class="keyword">true</span>; <span class="comment">// 是否允许使用Transformation转换</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Drawable fallbackDrawable; <span class="comment">// 后备回调符, 见文档</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fallbackId;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 转换操作集合, 对不同的资源类型进行转换,详见Transformation类</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; resourceClass = Object.class; <span class="comment">// 修改后资源类型, 详见定义部分</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Resources.Theme theme; <span class="comment">// 根据资源ID获取资源时所用的样式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isAutoCloneEnabled; <span class="comment">// 修改参数时是否会影响原参数, 如果为true, 修改参数前会先clone</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useUnlimitedSourceGeneratorsPool; <span class="comment">// 是否使用一个无限制的线程池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> onlyRetrieveFromCache; <span class="comment">// 仅从内存获取, 设置为true这不从数据源加载, 仅检查是否有缓存, 在类似省流量模式下比较有用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isScaleOnlyOrNoTransform = <span class="keyword">true</span>; <span class="comment">// 加载优化, 如果为true表使用原图不做转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="详细流程解析"><a href="#详细流程解析" class="headerlink" title="详细流程解析"></a>详细流程解析</h1><p>我们将按照总体设计中的层次图一次分析详细流程, 依次列出比较重要的流程.</p>
<h2 id="绑定声明周期逻辑"><a href="#绑定声明周期逻辑" class="headerlink" title="绑定声明周期逻辑"></a>绑定声明周期逻辑</h2><p>每个with会将当前context绑定一个RequestManager, 这段逻辑在:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint); <span class="comment">// 获得RequestManagerFragment , 根据之前从Context获取的FragmentManager </span></span><br><span class="line">  RequestManager requestManager = current.getRequestManager(); <span class="comment">// 从fragment中获取RequestManager 看是否已经绑定过了</span></span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode()); <span class="comment">// 创建一个RequestManager 和RequestManagerFragment 绑定</span></span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line"><span class="function">RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> android.app.FragmentManager fm, android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); <span class="comment">// 查找是否已经有Fragment</span></span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm); <span class="comment">// 是否有缓存的Framgnet</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> RequestManagerFragment(); </span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">     <span class="comment">// 创建一个新的Fragment, 添加到对应Context, 并且保存到缓存</span></span><br><span class="line">       handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); <span class="comment">// 当整个Fragment添加过程完成后, 从缓存中删除, 因为可以通过Context获取</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求调度逻辑"><a href="#请求调度逻辑" class="headerlink" title="请求调度逻辑"></a>请求调度逻辑</h2><p>RequestManager创建完成后, 通过load创建requestBuilder并设置参数, 然后通过into发起一个请求, 下面我们分析request状态转换和请求的构建<br>一个request的状态有以下八种:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Status &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Created but not yet running.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  PENDING,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * In the process of fetching media.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RUNNING,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Waiting for a callback given to the Target to be called to determine target dimensions.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  WAITING_FOR_SIZE,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Finished loading media successfully.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  COMPLETE,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Failed to load media, may be restarted.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  FAILED,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Cancelled by the user, may not be restarted.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  CANCELLED,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Cleared by the user with a placeholder set, may not be restarted.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  CLEARED,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Temporarily paused by the system, may be restarted.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  PAUSED,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>状态转换关系:<br><img src="https://s1.ax2x.com/2017/11/02/BUclE.png" alt=""></p>
<p>我们可以看到, 当声明周期为pause时, 请求首先被cancel, 然后在将状态设置为pause, 所以此时状态变化为 running -&gt; cancel -&gt; clear -&gt; pause</p>
<p>接着我们分析请求的开始, 请求逻辑的流程为: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  assertNotCallingCallbacks();</span><br><span class="line">  stateVerifier.throwIfRecycled(); <span class="comment">// 是否release</span></span><br><span class="line">  startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// model 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      width = overrideWidth;</span><br><span class="line">      height = overrideHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">    <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">    <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">    onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经在运行, 不能重复调用begin,这个是为了防止用户从外部调用begin,在没有加载完成时.</span></span><br><span class="line">  <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果加载完成, 直接将资源设置回去</span></span><br><span class="line">  <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">    onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class="line">  <span class="comment">// and can run again from the beginning.</span></span><br><span class="line">  <span class="comment">// 进入资源大小计算部分</span></span><br><span class="line">  status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    <span class="comment">// 如果有强制设置宽高, onSizeReady真正的执行逻辑</span></span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 交给target设置宽高, 最终也会调用onSizeReady</span></span><br><span class="line">    target.getSize(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置占位符</span></span><br><span class="line">  <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">      &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">    target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onSizeReady中会调用Engine的load函数进入真正的数据加载逻辑, 接下来我们分析load, load函数一共做了两件事, 查找内存缓存, 没有内存缓存的话, 生成EnginJob切入子线程请求数据. 以下是流程图:</p>
<p><img src="https://s1.ax2x.com/2017/11/02/BUavn.jpg" alt=""></p>
<p>load的参数在上面已经有说明, 我们不在重复描述, 当内存缓存没有命中时, 进入EngineJob进行任务调度, 由DecodeJob执行具体任务最后调用runWrapped, 我们来看runWrapped逻辑:</p>
<p>runWrapped根据不同的runReason执行不同的任务, RunReason枚举有三种类型</p>
<ul>
<li>INITIALIZE:第一次调度任务</li>
<li>WITCH_TO_SOURCE_SERVICE:本地缓存策略失败，尝试重新获取数据，两种情况；当stage为Stage.SOURCE，或者获取数据失败并且执行和回调发生在了不同的线程</li>
<li>DECODE_DATA:获取数据成功，但执行和回调不在同一线程，希望回到自己的线程去处理数据</li>
</ul>
<p>同时任务有五种状态:<br>INITIALIZE，RESOURCE_CACHE，DATA_CACHE，SOURCE，FINISHED<br>其中 RESOURCE_CACHE，DATA_CACHE，SOURCE分别对应三种数据加载策略:</p>
<ul>
<li>ResourceCacheGenerator ：尝试从修改过的资源缓存中获取，如果缓存未命中，尝试从DATA_CACHE中获取</li>
<li>DataCacheGenerator 尝试从未修改过的本地缓存中获取数据，如果缓存未命中则尝试从SourceGenerator中获取</li>
<li>SourceGenerator 从原始的资源中获取，可能是服务器，也可能是本地的一些原始资源</li>
</ul>
<p>使用哪个加载策略通过getNextStage函数判断, 由DiskCacheStrategy类控制实施哪种加载策略, 详见: <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/430/index.html" target="_blank" rel="noopener">DiskCacheStrategy</a><br>获取到合适的加载策略后, 由runGenerators执行加载策略:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  currentThread = Thread.currentThread(); <span class="comment">// 记录当前执行线程, 当结果返回时需要判断是否是在当前线程返回的结果</span></span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span> <span class="comment">// 是否取消以及是否有正确的加载器</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123; <span class="comment">// 加载器能否加载到数据</span></span><br><span class="line">    <span class="comment">// 进入到这里表示加载器没有加载到数据, 需要替换加载器</span></span><br><span class="line">    stage = getNextStage(stage);  <span class="comment">// 转换到下一种状态,</span></span><br><span class="line">    currentGenerator = getNextGenerator(); <span class="comment">// 根据状态获取加载器</span></span><br><span class="line">    <span class="comment">// 如果需要源加载器, 则用reschedule重新调度线程, 原因是如果读取Data或Resource缓存, 使用的是diskExecutor, 而加载source资源, 需要使用sourceExecutor.</span></span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule(); <span class="comment">// 发回sourceExecutor中的线程执行</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We've run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed(); <span class="comment">// 如果执行器都试过了, 还是没有成功的, 返回错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class="line">  <span class="comment">// onDataFetcherReady.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到 startNext是最终执行加载数据的地方, 也是真正使用ModelLoader的地方,  我们分别分析三种加载方式的startNext函数</p>
<p>ResourceCacheGenerator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Key&gt; sourceIds = helper.getCacheKeys(); <span class="comment">// 这里会根据load时候传入的model, 获取model对应的缓存资源的key</span></span><br><span class="line">  <span class="keyword">if</span> (sourceIds.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses(); <span class="comment">// 获取所有可以生成的resourceClass的dataClass和transcodeClass(就是所有可以转换为resourceClass的Class), 这里将在decode部分详细解析,</span></span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">    resourceClassIndex++;</span><br><span class="line">    <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;</span><br><span class="line">      sourceIdIndex++;</span><br><span class="line">      <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先说上面这段逻辑, 实际这个while是一个二维循环, 对每一个 sourceId(也就是对每一个缓存), 查询是否可以取到对应的 resourceClass. </span></span><br><span class="line">    <span class="comment">// 也就是遍历所有缓存, 查询能否通过缓存获取到一个resource, 这个resource不一定是目标resource, 但是它一定可以转换为目标resource</span></span><br><span class="line"></span><br><span class="line">    Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex); </span><br><span class="line">    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass); <span class="comment">// 获取当前资源对应的Transformation处理器</span></span><br><span class="line"></span><br><span class="line">    currentKey = <span class="keyword">new</span> ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class="line">        helper.getHeight(), transformation, resourceClass, helper.getOptions()); <span class="comment">// 根据这次请求特有参数, 生成一个key</span></span><br><span class="line">    cacheFile = helper.getDiskCache().get(currentKey); <span class="comment">// 获取资源对应缓存文件</span></span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile); <span class="comment">// 查询这种文件是否有对应的处理器, 并且返回是一组, 因为我们可以自定义ModelLoader</span></span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),</span><br><span class="line">            helper.getOptions());</span><br><span class="line">    <span class="comment">// 通过ModelLoader生成实际的数据加载器</span></span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>); <span class="comment">// 判断可以加载, 则加载数据, 具体参见DataFetcher的子类实现. 结果回调在onDataReady和onLoadFailed, 因为比较简单不单独说</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataCacheGenerator</p>
<p>DataCacheGenerator的缓存获取部分与ResourceCacheGenerator唯一的区别是,  DataCache缓存的是原图, 所以仅仅获取获取model对应的缓存资源的key就是上面的getCacheKeys, 然后直接通过sourceId获取cacheFile.</p>
<p>SourceGenerator:</p>
<p>要了解SourceGenerator逻辑, 我们要先了解源数据加载完成后会发生什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="comment">// 数据返回后, 首先判断是否需要将数据缓存到本地, isDataCacheable判断了DataSource, 在默认配置中, 如果为网络请求, 那么会先下载到文件, 再从文件加载.</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data; <span class="comment">// 如果需要缓存, 直接保存到文件</span></span><br><span class="line">      <span class="comment">// We might be being called back on someone else's thread. Before doing anything, we should</span></span><br><span class="line">      <span class="comment">// reschedule to get back onto Glide's thread.</span></span><br><span class="line">      <span class="comment">// 切换到srouceExecuter线程执行, 上面的注释说, 一个source请求可能在不同的线程发起, 我们想切换回Glide的线程处理后续工作.</span></span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再来看startNext</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123; <span class="comment">// 首先查询是否有需要缓存的数据, 如果有 将先把数据缓存, 然后生成一个sourceCacheGenerator. 他的类型是DataCacheGenerator, 走本地缓存读取逻辑</span></span><br><span class="line">      Object data = dataToCache;</span><br><span class="line">      dataToCache = <span class="keyword">null</span>;</span><br><span class="line">      cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    loadData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      <span class="comment">// 会获取所有model对应的资源加载器, hasLoadPath检查是否有一个可用的 model -&gt; transcode -&gt; resource路径, 如果有, 调用model加载器加载</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是加载过程的所有逻辑, 接下来我们介绍编码和转换过程</p>
<h2 id="编码和转换过程解析"><a href="#编码和转换过程解析" class="headerlink" title="编码和转换过程解析"></a>编码和转换过程解析</h2><p>在数据数据通过ModelLoader获取成功后, runWrapped会进入DECODE_DATA流程, 最终调用decodeFromFetcher函数创建编码路径和启动编码,<br>我们先通过流程图了解一个数据的处理流程:<br><img src="https://s1.ax2x.com/2017/11/02/BUssJ.png" alt=""><br>decodeFromFetcher函数首先准备好这条路径上的所有加载器, 通过LoadPath类封装, 通过源数据类型(dataClass)查找加载路径的逻辑在Registry类中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> &lt;Data, TResource, Transcode&gt; List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; getDecodePaths(</span><br><span class="line">      Class&lt;Data&gt; dataClass,  <span class="comment">// 由model从数据源加载的原始数据</span></span><br><span class="line">      Class&lt;TResource&gt; resourceClass,  <span class="comment">// 由源数据生成的编码和处理后的数据</span></span><br><span class="line">      Class&lt;Transcode&gt; transcodeClass) &#123; <span class="comment">// 由编码后的数据转换为的最终结果数据</span></span><br><span class="line"></span><br><span class="line">    List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取可以由data转化到的resource类的所有父类</span></span><br><span class="line">    List&lt;Class&lt;TResource&gt;&gt; registeredResourceClasses =</span><br><span class="line">        decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;TResource&gt; registeredResourceClass : registeredResourceClasses) &#123;</span><br><span class="line">      <span class="comment">// 获取之前得到的所有resource可以转换到的transcode类和所有父类</span></span><br><span class="line">      List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">          transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;Transcode&gt; registeredTranscodeClass : registeredTranscodeClasses) &#123;</span><br><span class="line">        <span class="comment">// 获取data-&gt;resource对应的Decoder, 是不是可以提出来到上一个循环</span></span><br><span class="line">        List&lt;ResourceDecoder&lt;Data, TResource&gt;&gt; decoders =</span><br><span class="line">            decoderRegistry.getDecoders(dataClass, registeredResourceClass);</span><br><span class="line">        <span class="comment">// 获得resource-&gt;transcode的Transcoder</span></span><br><span class="line">        ResourceTranscoder&lt;TResource, Transcode&gt; transcoder =</span><br><span class="line">            transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);</span><br><span class="line">        <span class="comment">// 生成一条data-&gt;resource-&gt;transcode的加载路径.</span></span><br><span class="line">        decodePaths.add(<span class="keyword">new</span> DecodePath&lt;&gt;(dataClass, registeredResourceClass,</span><br><span class="line">            registeredTranscodeClass, decoders, transcoder, exceptionListPool));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decodePaths;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 生成路径后, 在经过调度, 最后会调用DecodePaths的decode函数, 生成最终的资源</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options); <span class="comment">// 编码 会调用ResourceDecoder</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded); <span class="comment">// 转换 会调用Trasformation</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options); <span class="comment">// 转码 会调用Transcoder</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过decode生成的资源, 在确定有效后, 会调用notifyEncodeAndRelease做保存处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于资源的懒加载</span></span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">    ((Initializable) resource).initialize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里判断是否需要保存资源</span></span><br><span class="line">  Resource&lt;R&gt; result = resource;</span><br><span class="line">  LockedResource&lt;R&gt; lockedResource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">    lockedResource = LockedResource.obtain(resource);</span><br><span class="line">    result = lockedResource;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 向主线程回调, 最终会调用到target, 同时这里也会保存内存缓存</span></span><br><span class="line">  notifyComplete(result, dataSource);</span><br><span class="line"> <span class="comment">// 开始保存逻辑</span></span><br><span class="line">  stage = Stage.ENCODE;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 开始调用encoder保存</span></span><br><span class="line">    <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">      deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockedResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lockedResource.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    onEncodeComplete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此, 一个请求流程完全结束, Glide在模块化方面做得非常优秀, 在三级缓存的主架构下, 为我们提供和特别多的可配置流程. 其架构模型和模块划分思想非常值得学习,  我觉得有几个不足的地方就是, 模块分层使用了简单的回调, 使代码逻辑要在模块间跳来跳去, 使复杂度增加严重, 同时使用各种类型判断会拖累一些效率. 之后的sample会对Glide和Fresco等当前使用比较广泛的组件做对比, 同时对当前组件能支持的功能做一些标准的实现.</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://bumptech.github.io/glide/" target="_blank" rel="noopener">官网</a><br><a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="noopener">很多UML的出处和一些流程解析</a><br><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="noopener">一个非常详细的解析, 也拿了不少图过来…</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/31/OkHttp3-源码分析-version-3-7-0-第二章：工作流程分析/" rel="next" title="OkHttp3 源码分析(version: 3.7.0) - 第二章：工作流程分析">
                <i class="fa fa-chevron-left"></i> OkHttp3 源码分析(version: 3.7.0) - 第二章：工作流程分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/17/Glide图片尺寸策略详解/" rel="prev" title="Glide图片尺寸策略详解">
                Glide图片尺寸策略详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="G33kC4t" />
          <p class="site-author-name" itemprop="name">G33kC4t</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="Link" target="_blank" title="LinkLabel">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  LinkLabel
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/G33kC4t" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://example.com/" title="Title" target="_blank">Title</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#大纲"><span class="nav-number">1.</span> <span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总体设计简介"><span class="nav-number">2.</span> <span class="nav-text">总体设计简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一些概念"><span class="nav-number">2.1.</span> <span class="nav-text">一些概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总体流程"><span class="nav-number">2.2.</span> <span class="nav-text">总体流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主要模块-类和功能说明"><span class="nav-number">3.</span> <span class="nav-text">主要模块/类和功能说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#请求管理部分"><span class="nav-number">3.1.</span> <span class="nav-text">请求管理部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestManager-管理一组请求"><span class="nav-number">3.1.1.</span> <span class="nav-text">RequestManager 管理一组请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Target-资源接收模块"><span class="nav-number">3.1.2.</span> <span class="nav-text">Target 资源接收模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-请求控制"><span class="nav-number">3.1.3.</span> <span class="nav-text">Request 请求控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Engine-数据加载模块"><span class="nav-number">3.1.4.</span> <span class="nav-text">Engine 数据加载模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据处理部分"><span class="nav-number">3.2.</span> <span class="nav-text">数据处理部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EngineJob-DecodeJob"><span class="nav-number">3.2.1.</span> <span class="nav-text">EngineJob/DecodeJob</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ModelLoader-数据源加载器"><span class="nav-number">3.2.2.</span> <span class="nav-text">ModelLoader 数据源加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceDecoder"><span class="nav-number">3.2.3.</span> <span class="nav-text">ResourceDecoder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Encoder-ResourceEncoder"><span class="nav-number">3.2.4.</span> <span class="nav-text">Encoder/ResourceEncoder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceTranscoder"><span class="nav-number">3.2.5.</span> <span class="nav-text">ResourceTranscoder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource"><span class="nav-number">3.2.6.</span> <span class="nav-text">Resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataFetcher"><span class="nav-number">3.2.7.</span> <span class="nav-text">DataFetcher</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置部分"><span class="nav-number">3.3.</span> <span class="nav-text">配置部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GlideBuilder"><span class="nav-number">3.3.1.</span> <span class="nav-text">GlideBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestOptions"><span class="nav-number">3.3.2.</span> <span class="nav-text">RequestOptions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#详细流程解析"><span class="nav-number">4.</span> <span class="nav-text">详细流程解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定声明周期逻辑"><span class="nav-number">4.1.</span> <span class="nav-text">绑定声明周期逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求调度逻辑"><span class="nav-number">4.2.</span> <span class="nav-text">请求调度逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码和转换过程解析"><span class="nav-number">4.3.</span> <span class="nav-text">编码和转换过程解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文档"><span class="nav-number">5.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">G33kC4t</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
  <!-- 背景动画 -->
  <script type="text/javascript" src="/js/src/particle.js"></script>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

  
</body>
</html>
